?? core library

??<<
??? Returns a function with arguments <code>l</code> and <code>r</code> which
??? calls <code>f[e, r]</code> for each element <code>e</code> in <code>l</code>.
??? @type f fn
??? @return fn
??? @genre functional
MapLeft[f] := [l, r] -> { f&r => l }
??>>

??<<
??? Returns a function with arguments <code>l</code> and <code>r</code> which
??? calls <code>f[l, e]</code> for each element <code>e</code> in <code>r</code>.
??? @type f fn
??? @return fn
??? @genre functional
MapRight[f] := [l, r] -> { f&:l => r }
??>>

??<<
??? Returns the number of prime numbers less than or equal to <code>n</code>.
??? @type n number
??? @return number
??? @genre numeric/prime
??? @example Print[PrimePi[0:10]]
??? @example ?? [0, 0, 1, 2, 2, 3, 3, 4, 4, 4, 4]
PrimePi := @{#Series[Prime, _, include->true]}
??>>


??<<
??? Calls <code>Format[...args]</code>, which is passed then to <code>Print</code>.
??? @type args (*)...
??? @return [string]
??? @genre IO
Printf := Print@Format
??>>

??<<
??? Prints each element in <code>args</code>, separated by newlines, with no trailing newline. Returns <code>args</code>.
??? @type args (*)...
??? @return [(*)]
??? @genre IO
Output := Configure[Print, joiner->lf, after->es]@@Tie
??>>

??<<
??? Returns an array of base <code>base</code> digits of the numbers found in
??? <code>Range[...args]</code>
??? @type base number
??? @type args number...
??? @return [[number]]
??? @genre numeric/bases
??? @example Print => BaseRange[2, 0, 10]
??? @example ?? [0, 0, 0, 1]
??? @example ?? [0, 0, 1, 0]
??? @example ?? [0, 0, 1, 1]
??? @example ?? [0, 1, 0, 0]
??? @example ?? [0, 1, 0, 1]
??? @example ?? [0, 1, 1, 0]
??? @example ?? [0, 1, 1, 1]
??? @example ?? [1, 0, 0, 0]
??? @example ?? [1, 0, 0, 1]
??? @example ?? [1, 0, 1, 0]
BaseRange := {
    base .= _1
    arr .= ToBase[Range[...__2], base]
    maxlen .= Max[Size => arr]
    PadLeft&maxlen => arr
}
??>>

??<<
??? Returns an array of base <code>base</code> digits less than
??? <code>base ^ n</code>.
??? @type base number
??? @type n number
??? @return [[number]]
??? @genre numeric/bases
BaseBelow[base, n] := BaseRange[base, base^n-1]
??>>

??<<
??? Returns an array of base <code>2</code> digits of the numbers found in
??? <code>Range[...args]</code>
??? @type args number...
??? @return [[number]]
??? @genre numeric/bases
BinRange := 2&BaseRange
??>>

??<<
??? Returns an array of base <code>8</code> digits of the numbers found in
??? <code>Range[...args]</code>
??? @type args number...
??? @return [[number]]
??? @genre numeric/bases
OctRange := 8&BaseRange
??>>

??<<
??? Returns an array of base <code>16</code> digits of the numbers found in
??? <code>Range[...args]</code>
??? @type args number...
??? @return [[number]]
??? @genre numeric/bases
HexRange := 16&BaseRange
??>>

??<<
??? Returns an array of base <code>2</code> digits less than
??? <code>2 ^ n</code>.
??? @type n number
??? @return [[number]]
??? @genre numeric/bases
BinBelow := 2&BaseBelow
??>>
??<<
??? Returns an array of base <code>8</code> digits less than
??? <code>8 ^ n</code>.
??? @type n number
??? @return [[number]]
??? @genre numeric/bases
OctBelow := 8&BaseBelow
??>>
??<<
??? Returns an array of base <code>16</code> digits less than
??? <code>16 ^ n</code>.
??? @type n number
??? @return [[number]]
??? @genre numeric/bases
HexBelow := 16&BaseBelow
??>>

??<<
??? Splits <code>x</code> into <code>n</code> groups.
??? @type x [(*)]
??? @type n number
??? @return [[(*)]]
??? @genre list
ChopInto[x, n] := Chop[x, Ceiling[#x / n]]
??>>

??<<
??? Point class.
??? @genre numeric
??? @return Point
??? @type x number
??? @type y number
ClassNamed[Point]! {
    x .= _1
    y .= _2

    $map[f, vec] .= New[Point, f[x], f[y]]

    $string[] .= Format["(%s, %s)", x, y]
}
??>>

??<<
??? Returns a function which applies <code>f</code> to the grid of charcters in a string. This returns a string.
??? @type f fn
??? @return fn
??? @genre functional/string
OverGrid[f] := UnGrid@f@Grid
??>>

??<<
??? Returns a function which applies <code>f</code> to the charcters in a string. This returns a string.
??? @type f fn
??? @return fn
??? @genre functional/string
OverChars[f] := Join@f@Chars
??>>

??<<
??? Returns the minimum and the maximum of <code>list</code> in a 2-element array.
??? @type list [(*)]
??? @return [(*), (*)]
??? @genre list
??? @example list := [1, 9, 3, -5, 0, 0, 12]
??? @example Print[MinMax[list]]
??? @example ?? [-5, 12]
MinMax := Min # V # Max
??>>

??<<
??? Returns all positive integers which divide <code>n</code> which are also
??? less than or equal to <code>Sqrt[n]</code>.
??? @type n number
??? @return [number]
??? @genre numeric
RawDivisors[n] :=
    `|&_ \ 1:Sqrt[n]
??>>

??<<
??? Returns all positive integers which divide <code>n</code>.
??? @type n number
??? @return [number]
??? @genre numeric
Divisors := @{
    d .= RawDivisors[_]
    Concat[d, _ / d] |> Unique
}
??>>

??<<
??? Returns all but the last element of <code>list</code>.
??? @type list [(*)]
??? @return [(*)]
??? @genre list
Betail[list] := list[0...#list - 1]
??>>

??<<
??? Returns all but the first element of <code>list</code>.
??? @type list [(*)]
??? @return [(*)]
??? @genre list
Behead[list] := list[1...#list]
??>>

??<<
??? Returns all divisors of <code>n</code>, except <code>n</code>.
??? @type n number
??? @return [number]
??? @genre numeric
ProperDivisors := @(Betail@Divisors)
??>>

?? TODO: rainbow

??<<
??? Synonym for <code>GenerateFirst[N, ...args]</code>.
??? @return (*)
??? @type args (*)...
??? @type fn cond
??? @genre functional
Generate := GenerateFirst&:N
??>>

Echo := Configure[Print, after->es]

?? TODO: rings
?? Rings[mat, n] := 32

MaskMatrix[fs, mask, list] := (
    If[Concat[fs] =/= fs, fs .= [Id, fs]];;
    ZipWith<~Call, _, list~> => fs[mask]
)

??<<
??? Returns the real and imaginary portions of <code>n</code>.
??? @return [number]
??? @type n (*)
??? @genre numeric
ReIm := Re#V#Im
??>>

??
Norm[x] := (
    If[IsImaginary[x],
        Norm[ReIm[x]],
        Sqrt[Sum[x^2]]
    ]
)

Pairs := Slices&2
Triples := Slices&3

Left := First@V
Right := Last@V

DivisorPairs := @(Tr@Fork[Right, V, `/]#RawDivisors)

MultiJoin[list] := (
    dim .= ##list;;
    if()
)

LEGEND := "-.`_':=,""^;~cz><rs+?T/J\\i*!7FIltv1efuZn|35S{)L[aoCEYjx}(26Pyhkpq4bdwAG9KV8R]OUXB#Hg$&0D%MWQmN@"
??<<
??? Returns a string of characters which represent the "weight" of certain elements.
??? @type mat [[number]]
??? @type legend [(*)]
??? @type min number
??? @type max number
??? @optional legend
??? @optional min
??? @optional max
HeatMap[mat, legend, min, max] := (
    min ..= Min[mat];;
    max ..= Max[mat];;
    legend ..= LEGEND;;
    legend[(mat - min) / (max - min) * (#legend - 1) | Floor]
)
